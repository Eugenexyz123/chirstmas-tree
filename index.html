<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Luxury Christmas Tree v18.0 - iPhone Pro Max</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'PingFang SC', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* ç§»åŠ¨ç«¯å¥¢å UI æ ·å¼ */
        .glass-ui {
            position: absolute; padding: 15px; background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 15px; color: #d4af37;
            z-index: 100; transition: all 0.3s;
        }
        
        #left-panel { top: 80px; left: 15px; width: 160px; display: flex; flex-direction: column; gap: 10px; }
        #top-bar { top: env(safe-area-inset-top, 20px); right: 15px; display: flex; gap: 10px; }
        
        .btn {
            background: rgba(212, 175, 55, 0.2); border: 1px solid #d4af37;
            color: white; padding: 8px; border-radius: 8px; font-size: 12px;
            text-align: center; cursor: pointer; text-decoration: none;
        }

        #loader { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #020205; z-index: 1000; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
        }
        .loading-ring { width: 60px; height: 60px; border: 3px solid rgba(212, 175, 55, 0.1); border-top: 3px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        input[type="file"] { display: none; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="loader">
    <div class="loading-ring"></div>
    <div style="color: #d4af37; margin-top: 25px; font-size: 14px; letter-spacing: 3px;">æ­£åœ¨æ„å»ºæ‚¨çš„ç§äººåœ£è¯æ ‘...</div>
</div>

<div id="top-bar">
    <label class="btn"> ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ <input type="file" id="photo-upload" accept="image/*" multiple> </label>
    <div class="btn" onclick="toggleMusic()">ğŸµ éŸ³ä¹</div>
</div>

<div id="left-panel" class="glass-ui">
    <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">æ‰‹åŠ¿æ„Ÿåº”çŠ¶æ€</div>
    <div id="gesture-status" style="font-weight: bold;">ç­‰å¾…æ„Ÿåº”...</div>
    <hr style="border: 0.5px solid rgba(212, 175, 55, 0.2); width: 100%;">
    <div class="btn" onclick="setMode('TREE')">ğŸ„ åœ£è¯æ ‘å½¢æ€</div>
    <div class="btn" onclick="setMode('SCATTER')">âœ¨ æµªæ¼«æ˜Ÿäº‘</div>
    <div style="font-size: 10px; color: #aaa; margin-top: 5px;">æç¤ºï¼šåŒæŒ‡æåˆå¯æŠ“å–ç…§ç‰‡</div>
</div>

<div id="canvas-container"></div>
<video id="webcam-video" autoplay playsinline muted style="display:none"></video>

<script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    let scene, camera, renderer, composer, clock = new THREE.Clock();
    let particles = [], photoObjects = [];
    let handLandmarker, videoElement, mode = 'TREE';
    let bgm = new Audio('https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Kai_Engel/Chapter_One__Cold/Kai_Engel_-_04_-_Moonlight_Reprise.mp3'); // èˆ’ç¼“å¤å…¸èƒŒæ™¯
    bgm.loop = true;

    async function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.015);
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 50);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        createLuxuryParticles();
        setupPostProcessing();
        await setupAI();

        // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
        document.getElementById('photo-upload').addEventListener('change', handleUpload);

        document.getElementById('loader').style.display = 'none';
        animate();
    }

    function createLuxuryParticles() {
        const group = new THREE.Group();
        const geo = new THREE.SphereGeometry(0.15, 6, 6);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            emissive: 0xffaa00,
            emissiveIntensity: 0.5,
            metalness: 1,
            roughness: 0
        });

        for (let i = 0; i < 3000; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            const p = {
                mesh: mesh,
                treePos: getTreePos(i),
                scatterPos: new THREE.Vector3().setFromSphericalCoords(
                    20 + Math.random() * 20, 
                    Math.random() * Math.PI, 
                    Math.random() * Math.PI * 2
                ),
                speed: 0.02 + Math.random() * 0.04
            };
            mesh.position.copy(p.scatterPos);
            group.add(mesh);
            particles.push(p);
        }
        scene.add(group);
    }

    function getTreePos(i) {
        const h = 25;
        const ratio = Math.pow(Math.random(), 1.2);
        const y = ratio * h - h/2;
        const r = (h/2 - y) * 0.35;
        const angle = ratio * 50 + Math.random() * Math.PI * 2;
        return new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
    }

    function handleUpload(e) {
        const files = Array.from(e.target.files);
        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const tex = new THREE.TextureLoader().load(event.target.result);
                createPhotoMesh(tex);
            };
            reader.readAsDataURL(file);
        });
    }

    function createPhotoMesh(texture) {
        const geo = new THREE.PlaneGeometry(4, 5);
        const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        
        // åˆå§‹ä½ç½®åœ¨æ ‘çš„éšæœºä½ç½®
        const angle = Math.random() * Math.PI * 2;
        mesh.position.set(Math.cos(angle)*10, (Math.random()-0.5)*15, Math.sin(angle)*10);
        mesh.lookAt(0,0,0);
        
        scene.add(mesh);
        photoObjects.push({ 
            mesh, 
            originalPos: mesh.position.clone(),
            state: 'IDLE' 
        });
    }

    async function setupAI() {
        videoElement = document.getElementById('webcam-video');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        videoElement.srcObject = stream;
        
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        detectHand();
    }

    function detectHand() {
        const results = handLandmarker.detectForVideo(videoElement, performance.now());
        const status = document.getElementById('gesture-status');
        
        if (results.landmarks && results.landmarks.length > 0) {
            const lm = results.landmarks[0];
            const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            
            if (dist < 0.05) {
                status.innerText = "ğŸ‘Œ æ­£åœ¨æŠ“å–...";
                grabClosestPhoto();
            } else {
                status.innerText = "ğŸ‘‹ å·²æ„Ÿåº”æ‰‹æŒ";
                releasePhotos();
            }
        } else {
            status.innerText = "ğŸ” å¯»æ‰¾æ‰‹åŠ¿...";
        }
        requestAnimationFrame(detectHand);
    }

    function grabClosestPhoto() {
        if (photoObjects.length === 0) return;
        // æŠ“å–é€»è¾‘ä¼˜åŒ–ï¼šå°†æœ€è¿‘çš„ç…§ç‰‡ç§»åŠ¨åˆ°æ‘„åƒæœºå‰
        const target = photoObjects[0]; 
        target.state = 'GRABBED';
    }

    function releasePhotos() {
        photoObjects.forEach(p => p.state = 'IDLE');
    }

    function setupPostProcessing() {
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.elapsedTime;

        particles.forEach(p => {
            const dest = (mode === 'TREE') ? p.treePos : p.scatterPos;
            p.mesh.position.lerp(dest, p.speed);
            // å‘¼å¸é—ªçƒæ•ˆæœ
            p.mesh.material.emissiveIntensity = 0.5 + Math.sin(time * 3 + p.mesh.id) * 0.3;
        });

        photoObjects.forEach(p => {
            if (p.state === 'GRABBED') {
                const cameraForward = new THREE.Vector3(0, 0, -15).applyQuaternion(camera.quaternion).add(camera.position);
                p.mesh.position.lerp(cameraForward, 0.1);
                p.mesh.lookAt(camera.position);
            } else {
                p.mesh.position.lerp(p.originalPos, 0.05);
                p.mesh.rotation.y += 0.01;
            }
        });

        scene.rotation.y += 0.002;
        composer.render();
    }

    window.toggleMusic = () => { bgm.paused ? bgm.play() : bgm.pause(); };
    window.setMode = (m) => mode = m;
    window.init = init;
    
    // é¦–æ¬¡ç‚¹å‡»å¯åŠ¨
    window.addEventListener('touchstart', () => { if(renderer) return; init(); }, { once: true });
</script>
</body>
</html>
