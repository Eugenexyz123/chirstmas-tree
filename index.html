<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Magic Christmas - Creative Technologist Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --champagne-gold: #d4af37;
            --cream-white: #fceea7;
            --glass-bg: rgba(0, 0, 0, 0.65);
        }

        body { margin: 0; background: #000; overflow: hidden; font-family: 'Times New Roman', serif; }

        /* --- UI 设计 --- */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease;
        }
        .spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 1px solid rgba(212, 175, 55, 0.1);
            border-top: 1px solid var(--champagne-gold);
            animation: spin 1s linear infinite;
        }
        .loader-text {
            margin-top: 20px; color: var(--champagne-gold);
            letter-spacing: 4px; font-size: 12px; font-family: 'Cinzel', serif;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .header-title {
            position: fixed; top: 5%; left: 50%; transform: translateX(-50%);
            font-family: 'Cinzel', serif; font-size: 56px; margin: 0;
            background: linear-gradient(to bottom, #fff, var(--champagne-gold));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
            z-index: 10; pointer-events: none;
        }

        .upload-wrapper {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 20; text-align: center;
        }
        .elegant-btn {
            background: var(--glass-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--champagne-gold); color: var(--cream-white);
            padding: 12px 30px; cursor: pointer; border-radius: 4px;
            font-size: 14px; letter-spacing: 2px; transition: 0.3s;
        }
        .elegant-btn:hover { background: rgba(212, 175, 55, 0.2); box-shadow: 0 0 15px var(--champagne-gold); }
        .hint-text { color: var(--champagne-gold); opacity: 0.6; font-size: 10px; margin-top: 8px; }

        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }
        
        #webcam-container {
            position: fixed; bottom: 10px; right: 10px;
            width: 160px; height: 120px; opacity: 0; /* 规格要求不可见 */
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">LOADING HOLIDAY MAGIC</div>
    </div>

    <h1 class="header-title">Merry Christmas</h1>

    <div class="upload-wrapper" id="ui-controls">
        <label class="elegant-btn">
            ADD MEMORIES
            <input type="file" id="file-input" hidden accept="image/*">
        </label>
        <div class="hint-text">Press 'H' to Hide Controls</div>
    </div>

    <div id="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="cv-canvas" width="160" height="120"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心配置 ---
        const CONFIG = {
            treeHeight: 25,
            treeRadius: 10,
            pCount: 1500,
            dustCount: 2500,
            colors: { gold: 0xd4af37, red: 0x880000, white: 0xfceea7, green: 0x0a2a12 }
        };

        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusTarget: null,
            handData: { x: 0, y: 0, detected: false },
            mainRotation: new THREE.Euler()
        };

        // --- 场景组件 ---
        let scene, camera, renderer, composer, mainGroup, particles = [], handLandmarker;
        const clock = new THREE.Clock();

        // --- 启动初始化 ---
        async function init() {
            setupThree();
            setupPostProcessing();
            setupLights();
            await createContent();
            initMediaPipe();
            setupInteractions();
            
            // 淡出 Loader
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 800);
            
            animate();
        }

        function setupThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 2, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.2;
            document.body.appendChild(renderer.domElement);

            const pmrem = new THREE.PMREMGenerator(renderer);
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.45, 0.4, 0.7
            );
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const internalLight = new THREE.PointLight(0xff6600, 2, 20);
            mainGroup.add(internalLight);

            const goldSpot = new THREE.SpotLight(0xd4af37, 1200);
            goldSpot.position.set(30, 40, 40);
            scene.add(goldSpot);

            const blueSpot = new THREE.SpotLight(0x0000ff, 600);
            blueSpot.position.set(-30, 20, -30);
            scene.add(blueSpot);
        }

        // --- 粒子与内容 ---
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh;
                this.type = type;
                this.velocity = new THREE.Vector3().randomDirection().multiplyScalar(0.2);
                this.rotationSpeed = new THREE.Vector3().randomDirection().multiplyScalar(0.02);
                this.targetPos = new THREE.Vector3();
                this.baseScale = mesh.scale.x;
                
                // 预计算树形位置
                const t = Math.random();
                const radius = CONFIG.treeRadius * (1 - t);
                const angle = t * 50 * Math.PI;
                this.posTree = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2),
                    Math.sin(angle) * radius
                );
                
                // 预计算散开位置
                const r = 8 + Math.random() * 12;
                this.posScatter = new THREE.Vector3().randomDirection().multiplyScalar(r);
            }

            update(dt) {
                let dest = (STATE.mode === 'TREE') ? this.posTree : this.posScatter;
                let lerpSpeed = 0.05;

                if (STATE.mode === 'FOCUS' && this.mesh === STATE.focusTarget) {
                    dest = new THREE.Vector3(0, 2, 35);
                    this.mesh.scale.lerp(new THREE.Vector3(4.5, 4.5, 4.5), 0.1);
                    this.mesh.lookAt(camera.position);
                } else if (STATE.mode === 'FOCUS') {
                    dest = this.posScatter.clone().multiplyScalar(1.5);
                    this.mesh.scale.lerp(new THREE.Vector3(this.baseScale, this.baseScale, this.baseScale), 0.1);
                } else {
                    this.mesh.scale.lerp(new THREE.Vector3(this.baseScale, this.baseScale, this.baseScale), 0.1);
                }

                this.mesh.position.lerp(dest, lerpSpeed);

                if (STATE.mode === 'SCATTER') {
                    this.mesh.rotation.x += this.rotationSpeed.x;
                    this.mesh.rotation.y += this.rotationSpeed.y;
                }
            }
        }

        async function createContent() {
            // 纹理生成：糖果手杖
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 15;
            ctx.beginPath(); ctx.moveTo(-10, 10); ctx.lineTo(74, 74); ctx.stroke();
            const caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(2, 4);

            // 几何体与材质
            const boxGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);
            
            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 0.9, roughness: 0.2 });
            const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.8 });
            const redMat = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, clearcoat: 1, metalness: 0.5 });

            // 1. 生成主体粒子
            for (let i = 0; i < CONFIG.pCount; i++) {
                const isBox = Math.random() > 0.5;
                const mesh = new THREE.Mesh(
                    isBox ? boxGeo : sphereGeo,
                    Math.random() > 0.3 ? (Math.random() > 0.5 ? goldMat : greenMat) : redMat
                );
                mesh.scale.setScalar(0.5 + Math.random());
                mainGroup.add(mesh);
                particles.push(new Particle(mesh, 'DECO'));
            }

            // 2. 生成尘埃
            const dustGeo = new THREE.IcosahedronGeometry(0.05, 0);
            const dustMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.white, transparent: true, opacity: 0.6 });
            for (let i = 0; i < CONFIG.dustCount; i++) {
                const d = new THREE.Mesh(dustGeo, dustMat);
                mainGroup.add(d);
                particles.push(new Particle(d, 'DUST'));
            }

            // 3. 初始默认照片
            createPhotoFrame("JOYEUX NOEL", true);
        }

        function createPhotoFrame(source, isText = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            if(isText) {
                ctx.fillStyle = '#111'; ctx.fillRect(0,0,512,512);
                ctx.fillStyle = CONFIG.colors.gold; ctx.font = 'bold 60px Cinzel';
                ctx.textAlign = 'center'; ctx.fillText(source, 256, 270);
            }

            const loader = new THREE.TextureLoader();
            const texture = isText ? new THREE.CanvasTexture(canvas) : source;
            texture.colorSpace = THREE.SRGBColorSpace;

            const frameGeo = new THREE.BoxGeometry(6, 6, 0.4);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 0.8 });
            const photoGeo = new THREE.PlaneGeometry(5.4, 5.4);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });

            const group = new THREE.Group();
            const frame = new THREE.Mesh(frameGeo, frameMat);
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.21;
            group.add(frame, photo);
            
            mainGroup.add(group);
            const p = new Particle(group, 'PHOTO');
            particles.push(p);
            return p;
        }

        // --- 交互与 CV ---
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO"
            });
            
            const video = document.getElementById('webcam');
            if (navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
            }
        }

        function setupInteractions() {
            // 文件上传
            document.getElementById('file-input').onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (t) => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        createPhotoFrame(t, false);
                    });
                };
                reader.readAsDataURL(file);
            };

            // H 键隐藏 UI
            window.addEventListener('keydown', (e) => {
                if(e.key.toLowerCase() === 'h') {
                    document.getElementById('ui-controls').classList.toggle('ui-hidden');
                    document.querySelector('.header-title').classList.toggle('ui-hidden');
                }
            });
        }

        function detectGestures(results) {
            if (!results.landmarks || results.landmarks.length === 0) return;
            
            const landmarks = results.landmarks[0];
            const thumb = landmarks[4];
            const index = landmarks[8];
            const wrist = landmarks[0];
            const middle = landmarks[12];
            const ring = landmarks[16];
            const pinky = landmarks[20];

            // 逻辑映射
            const distPinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            const avgFingerDist = (
                Math.hypot(index.x - wrist.x, index.y - wrist.y) +
                Math.hypot(middle.x - wrist.x, middle.y - wrist.y) +
                Math.hypot(ring.x - wrist.x, ring.y - wrist.y) +
                Math.hypot(pinky.x - wrist.x, pinky.y - wrist.y)
            ) / 4;

            // 模式切换
            if (distPinch < 0.05) {
                if (STATE.mode !== 'FOCUS') {
                    const photos = particles.filter(p => p.type === 'PHOTO');
                    STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                    STATE.mode = 'FOCUS';
                }
            } else if (avgFingerDist < 0.25) {
                STATE.mode = 'TREE';
                STATE.focusTarget = null;
            } else if (avgFingerDist > 0.4) {
                STATE.mode = 'SCATTER';
                STATE.focusTarget = null;
            }

            // 旋转映射 (使用掌心坐标 9)
            STATE.handData.x = (landmarks[9].x - 0.5) * 2;
            STATE.handData.y = (landmarks[9].y - 0.5) * 2;
        }

        // --- 渲染循环 ---
        function animate() {
            const dt = clock.getDelta();
            const et = clock.getElapsedTime();

            if (handLandmarker && document.getElementById('webcam').readyState >= 2) {
                const detections = handLandmarker.detectForVideo(document.getElementById('webcam'), performance.now());
                detectGestures(detections);
            }

            // 平滑旋转
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, STATE.handData.x * 2, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.handData.y * 1, 0.05);
            
            // 自动微旋
            if (STATE.mode === 'TREE') mainGroup.rotation.y += dt * 0.2;

            particles.forEach(p => p.update(dt));

            composer.render();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
